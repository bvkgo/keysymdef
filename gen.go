// Copyright (c) 2024 BVK Chaitanya

//go:build ignore

// This program generates Go constants for X11 keysyms and corresponding
// unicode code points from the /usr/include/X11/keysymdef.h file.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
)

func main() {
	type Entry struct {
		Keysym    string
		Value     uint32
		Codepoint uint32
		Comment   string
	}
	var items []*Entry

	keysymdef, err := os.ReadFile("/usr/include/X11/keysymdef.h")
	if err != nil {
		log.Fatalf("reading keysymdef.h: %v", err)
	}

	re := `^#define \s+ (XK_[a-zA-Z_0-9]+) \s+ 0x([0-9a-fA-F]+) \s* (/\* [\s\(]? (U\+([0-9a-fA-F]+))? .* \*/)? .* $`
	keysymdefRe := regexp.MustCompile(strings.Replace(re, " ", "", -1))

	s := bufio.NewScanner(bytes.NewBuffer(keysymdef))
	for s.Scan() {
		text := strings.TrimSpace(s.Text())
		m := keysymdefRe.FindStringSubmatch(text)
		if m == nil {
			continue
		}
		value, err := strconv.ParseUint(m[2], 16, 32)
		if err != nil {
			log.Fatalf("could not parse keysym value: %v", err)
		}

		item := &Entry{
			Keysym:  m[1],
			Value:   uint32(value),
			Comment: m[3],
		}

		if len(m[5]) != 0 {
			code, err := strconv.ParseUint(m[5], 16, 32)
			if err != nil {
				log.Fatalf("could not parse unicode codepoint: %v", err)
			}
			item.Codepoint = uint32(code)
		}
		items = append(items, item)
	}

	// Remove duplicates. If name/value duplicates are found, prefer the item
	// with a unicode codepoint or a comment over.
	pickOne := func(i, j int) int {
		if items[i] == nil && items[j] != nil {
			return j
		}
		if items[j] == nil && items[i] != nil {
			return i
		}
		if items[i].Codepoint == 0 && items[j].Codepoint != 0 {
			items[i] = nil
			return j
		}
		if items[j].Codepoint == 0 && items[i].Codepoint != 0 {
			items[j] = nil
			return i
		}
		if len(items[i].Comment) == 0 && len(items[j].Comment) != 0 {
			items[i] = nil
			return j
		}
		if len(items[j].Comment) == 0 && len(items[i].Comment) != 0 {
			items[j] = nil
			return i
		}
		items[i] = nil
		return j
	}

	nameDupMap := make(map[string]int)
	valueDupMap := make(map[uint32]int)
	for i, item := range items {
		if j, ok := nameDupMap[item.Keysym]; ok {
			i = pickOne(i, j)
		}
		if j, ok := valueDupMap[item.Value]; ok {
			i = pickOne(i, j)
		}
		nameDupMap[item.Keysym] = i
		valueDupMap[item.Value] = i
	}
	items = slices.DeleteFunc(items, func(v *Entry) bool { return v == nil })

	// Prepare a buffer with constant definitions.
	constsBuf := &bytes.Buffer{}
	for _, item := range items {
		if len(item.Comment) > 0 {
			fmt.Fprintf(constsBuf, "%s = 0x%x %s\n", item.Keysym, item.Value, item.Comment)
		} else {
			fmt.Fprintf(constsBuf, "%s = 0x%x\n", item.Keysym, item.Value)
		}
	}

	// Prepare a buffer with entries for keysym string to value map.
	symsBuf := &bytes.Buffer{}
	for _, item := range items {
		fmt.Fprintf(symsBuf, "%q: 0x%x,\n", item.Keysym, item.Value)
	}

	// Prepare a buffer with entries for keysym to unicode codepoint map.
	codesBuf := &bytes.Buffer{}
	seen := make(map[uint32]struct{})
	for _, item := range items {
		if _, ok := seen[item.Value]; ok {
			continue
		}
		seen[item.Value] = struct{}{}

		if item.Codepoint != 0 {
			fmt.Fprintf(codesBuf, "%s: 0x%x, %s\n", item.Keysym, item.Codepoint, item.Comment)
		}
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, `// generated by go generate; DO NOT EDIT.
package keysymdef

import "github.com/jezek/xgb/xproto"

const (
`+constsBuf.String()+`
)

var stringKeysyms = map[string]xproto.Keysym{
`+symsBuf.String()+`
}

var keysymCodePoints = map[xproto.Keysym]rune{
`+codesBuf.String()+`
}
`)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("formatting output: %v", err)
	}

	if err := os.WriteFile("keysyms.go", formatted, 0644); err != nil {
		log.Fatalf("writing keysyms.go: %v", err)
	}
}
